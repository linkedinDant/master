PITTON Olivier n°2800439 - Groupe 4

1°) Conventions

Tous les fichiers représentant du code, des binaires ou des bibliothèques (*.c, *.h, *.o, ...) sont sous la forme exo[X] où X est le numéro de l'exercice.
Exemple : exo5.c

Pour chaque exercice nécessitant du code, un header et un fichier source sont inclus, respectant les précédentes conventions.

2°) Descriptions du contenu des répertoires

include/ : Le dossier contient toutes les en-têtes de fichiers sources (*.h) pour chaque exercice.
  exo1 : Header de l'exercice 1.
  exo2 : Header de l'exercice 2.
  exo3 : Header de l'exercice 3.
  exo4 : Header de l'exercice 4.
  exo5 : Header de l'exercice 5, pour les deux fichiers sources.
  exo7 : Header de l'exercice 7.
  exo8 : Header de l'exercice 8.
  extended-grep : Header de l'exercice 6.

src/ : Le dossier contient tous les fichiers sources (*.c) pour chaque exercice.
  exo1 : Source de l'exercice 1.
  exo2 : Source de l'exercice 2.
  exo3 : Source de l'exercice 3.
  exo4 : Source de l'exercice 4.
  exo5-open : Source de l'exercice 5, avec open.
  exo5-fopen : Source de l'exercice 5, avec fopen.
  exo7 : Source de l'exercice 7.
  exo8 : Source de l'exercice 8.
  extended-grep : Source de l'exercice 6.
  
3°) Directives du makefile

Afin d'utiliser pleinement les possibilités vues en cours pour la réalisation d'un makefile, celui-ci a été enrichi avec des variables internes et personnalisées.

Le makefile définit cinq variables personnalisées :
  
  CC -> La commande représentant le compilateur utilisé (ici gcc).
  CFLAGS -> Les arguments à spécifier au compilateur de manière permanente
  ALL -> La liste de toutes les cibles, permettant de faire la compilation et l'édition de lien de tout le TME.
  LIB -> La commande générique pour créer un fichier *.a depuis un fichier *.o
  OBJ -> Une simple variable pour factoriser les appels aux fichiers objets.  
  
Les cibles sont les suivantes :

  all -> Lance la compilation de tout le TME.
  clean -> Nettoie les fichiers exécutables et fichiers objets.
  exo1 -> Compile l'exercice dans le dossier obj/ et copie le fichier objet dans le dossier bin/
  exo2 -> Compile l'exercice dans le dossier obj/ et copie le fichier objet dans le dossier bin/
  exo3 -> Compile l'exercice dans le dossier obj/ et copie le fichier objet dans le dossier bin/
  exo4 -> Compile l'exercice dans le dossier obj/ et copie le fichier objet dans le dossier bin/
  exo5 -> Lance les directives exo5-fopen et exo5-open.
  exo5-open -> Compile l'exercice dans le dossier obj/ et copie le fichier objet dans le dossier bin/
  exo5-fopen -> Compile l'exercice dans le dossier obj/ et copie le fichier objet dans le dossier bin/
  exo7 -> Compile l'exercice dans le dossier obj/ et copie le fichier objet dans le dossier bin/
  exo8 -> Compile l'exercice dans le dossier obj/ et copie le fichier objet dans le dossier bin/
  extended-grep -> Compile l'exercice 6 dans le dossier obj/ et copie le fichier objet dans le dossier bin/
  
Enfin, toutes les directives affichent un message au lancement et à la fin de celles-ci.

4°) Etat d'avancement des exercices

Tous les exercices sont terminés et fonctionnent.

Exercice 1

Question : quels sont les contenus possibles du fichier fich1 ?

Si le père s'execute pleinement en premier "45hi123"
Si le fils s'exécute pleinement en premier "fghie123"
Si le fils est lancé en premier et qu'une commutation intervient avant le second write, on obtient "45hie123"
Si le père s'exécute en premier et qu'une commutation intervient avant le second write, on obtient "45cde123hi"

Exercice 5

Question : quelle différence observez-vous ? 
Expliquez cette différence.

En utilisant open (et les fonctions associées), les processus commutent. Ainsi, selon la taille du fichier, les processus s'alternent au bout d'un certain nombre de caractères. En revanche, pour fopen, seul un processus lit l'ensemble des caractères.

Cela s'explique par le fait que les fonctions de la bibliothèque C utilisent des buffers et ne font donc pas toujours d'appels système, puisque l'on travaille
directement dans l'espace d'adressage du processus courant. Ainsi, en plus d'éviter les appels systèmes provoquant des commutations, ... chaque processus fils a son propre buffer contenant ses données et effectue la lecture plus vite. On remonte une fois le fichier en mémoire, et on lit les caractères, au lieu de faire N appel système.