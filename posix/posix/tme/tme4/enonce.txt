
TME 4 - IPC System V


 

Objectifs

Mettre en pratique les notions de file de message et de segment de mémoire partagée.
Comprendre les phénomènes d'incohérence pouvant être induits par le partage de mémoire.
Mettre en œuvre les mécanismes de synchronisation relatifs aux IPCs System V.

 
Remarques importantes

Les files de messages, les tableaux de sémaphores, et les segments de mémoire partagée que vous créez à chaque exécution doivent impérativement être détruits en fin de programme. Si vous ne respectez pas cette règle, vous risquez de vous retrouver face à des comportements incohérents liés à des variables dont les valeurs sont restées en mémoire après la terminaison du programme qui les a créées.
Pour afficher l'ensemble des IPCs présentes en mémoire, vous pouvez utiliser la commande ipcs.
Les commandes ipcrm et ipcclean servent à détruire des IPCs depuis le terminal. NB: ipcclean ne détruit pas les files de messages.

Par ailleurs, l'ensemble de ce TME met en oeuvre les IPC System V, et non POSIX. En début de vos fichiers source, il faut donc remplacer :
          #define XOPEN_SOURCE 700
par
          #define SVID_SOURCE 1
 
 
Exercices

 
Exercice 1 : Remontée de valeurs par file de messages

Ecrivez un programme où le processus principal crée N processus fils. Chaque processus fils génère une valeur aléatoire random_val qu'il insère dans une file de messages System V à destination du processus principal. La valeur aléatoire est calculée ainsi :
random_val = (int) (10*(float)rand()/ RAND_MAX);
De son côté, le processus principal doit attendre la terminaison de tous ses fils, puis extraire toutes les valeurs de la file de messages pour ensuite les additionner et enfin afficher la somme résultante.
 

Exercice 2 : Remontée de valeurs par partage de mémoire

Modifiez le programme de l'exercice 1 pour que les valeurs aléatoires transmises par les fils passent non plus par une file de messages, mais par un segment de mémoire partagée System V.
 
  
Exercice 3 : Serveur de valeurs aléatoires à files multiples

On veut encore que le programme principal crée N processus fils. Chaque processus est associé à une file de messages MQi (i le numéro d’ordre de création du processus fils  : 0 < i < N-1 ; le programme principal est associé à la file MQN.) Il y a donc en tout N+1 files de messages.
Cette fois-ci la valeur aléatoire générée par chaque processus fils, notée max_msg_i (1 <= max_msg_i <= N), représente le nombre de messages que le processus fils veut recevoir de son père. Une fois générée, chaque fils envoie cette valeur à son père par le biais de la file de messages associée au processus principal. Chaque processus fils attend ensuite sur sa propre file de messages que son père lui renvoie max_msg_i messages.
Dans ces messages, le processus père insère à chaque fois une valeur tirée aléatoirement entre 0 et 100.
Lorsque tous les messages ont été extraits de sa file, chaque processus fils fait la somme des valeurs reçues et affiche le résultat.
 

Exercice 4 : Serveur de valeurs aléatoires à file unique

Reprenez le programme de l'exercice 3 ; mais cette fois-ci les processus échangent tous dans une même et unique file de messages.
 

Exercice 5 : Rendez-vous par sémaphores

Une barrière est un mécanisme de synchronisation. Elle permet à N processus de prendre rendez-vous en un point donné de leur exécution. Quand un des processus atteint la barrière, il reste bloqué jusqu’à ce que tous les autres arrivent à la barrière. Lorsque les N processus sont arrivés à la barrière, chacun peut alors reprendre son exécution.

Sans utiliser de compteur partagé, programmez la fonction  wait_barrier(int N) qui permet à N processus de se synchroniser sur une barrière. Testez votre programme en exécutant plusieurs processus distincts avec le code suivant :
void process (int NB_PCS) {
    printf ("avant barrière);
    wait_barrier (NB_PCS);
    printf ("après barrière);
    exit (0);
}

L'affichage devra être le suivant :
avant barrière
avant barrière
après barrière 
après barrière
En d’autres termes,  on veut que tous les messages  « avant barrière » soient affichés avant les messages « après barrière ».
 

Exercice 6 : ProducteurS / ConsommateurS

Reprenez l'exercice 4 du TME 3 en construisant votre pile dans un segment de mémoire partagée.


